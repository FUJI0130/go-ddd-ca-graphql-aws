package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"time"

	"github.com/FUJI0130/go-ddd-ca/internal/interface/graphql/dataloader"
	"github.com/FUJI0130/go-ddd-ca/internal/interface/graphql/generated"
	"github.com/FUJI0130/go-ddd-ca/internal/interface/graphql/model"
	"github.com/FUJI0130/go-ddd-ca/internal/usecase/dto"
)

// CreateTestSuite はテストスイート作成ミューテーションのリゾルバーです
// 入力としてCreateTestSuiteInputを受け取り、新しいテストスイートを作成します
func (r *mutationResolver) CreateTestSuite(ctx context.Context, input model.CreateTestSuiteInput) (*model.TestSuite, error) {
	// DTOに変換
	createDTO := &dto.TestSuiteCreateDTO{
		Name:               input.Name,
		EstimatedStartDate: input.EstimatedStartDate,
		EstimatedEndDate:   input.EstimatedEndDate,
	}

	// オプションフィールドの処理
	if input.Description != nil {
		createDTO.Description = *input.Description
	}

	if input.RequireEffortComment != nil {
		createDTO.RequireEffortComment = *input.RequireEffortComment
	} else {
		createDTO.RequireEffortComment = false // デフォルト値
	}

	// ユースケースを呼び出し
	result, err := r.TestSuiteUseCase.CreateTestSuite(ctx, createDTO)
	if err != nil {
		return nil, err
	}

	// レスポンスDTOをGraphQLモデルに変換
	return &model.TestSuite{
		ID:                   result.ID,
		Name:                 result.Name,
		Description:          result.Description,
		Status:               mapStatusToEnum(result.Status),
		EstimatedStartDate:   result.EstimatedStartDate,
		EstimatedEndDate:     result.EstimatedEndDate,
		RequireEffortComment: result.RequireEffortComment,
		Progress:             result.Progress,
		CreatedAt:            result.CreatedAt,
		UpdatedAt:            result.UpdatedAt,
	}, nil
}

// UpdateTestSuite はテストスイート更新ミューテーションのリゾルバーです
// IDと更新情報を受け取り、既存のテストスイートを更新します
func (r *mutationResolver) UpdateTestSuite(ctx context.Context, id string, input model.UpdateTestSuiteInput) (*model.TestSuite, error) {
	// DTOに変換
	updateDTO := &dto.TestSuiteUpdateDTO{}

	// 更新するフィールドのみDTOに設定
	if input.Name != nil {
		updateDTO.Name = input.Name
	}
	if input.Description != nil {
		updateDTO.Description = input.Description
	}
	if input.EstimatedStartDate != nil {
		updateDTO.EstimatedStartDate = (*time.Time)(input.EstimatedStartDate)
	}
	if input.EstimatedEndDate != nil {
		updateDTO.EstimatedEndDate = (*time.Time)(input.EstimatedEndDate)
	}
	if input.RequireEffortComment != nil {
		updateDTO.RequireEffortComment = input.RequireEffortComment
	}

	// ユースケースを呼び出し
	result, err := r.TestSuiteUseCase.UpdateTestSuite(ctx, id, updateDTO)
	if err != nil {
		return nil, err
	}

	// レスポンスをGraphQLモデルに変換
	return &model.TestSuite{
		ID:                   result.ID,
		Name:                 result.Name,
		Description:          result.Description,
		Status:               mapStatusToEnum(result.Status),
		EstimatedStartDate:   result.EstimatedStartDate,
		EstimatedEndDate:     result.EstimatedEndDate,
		RequireEffortComment: result.RequireEffortComment,
		Progress:             result.Progress,
		CreatedAt:            result.CreatedAt,
		UpdatedAt:            result.UpdatedAt,
	}, nil
}

// UpdateTestSuiteStatus はテストスイートステータス更新ミューテーションのリゾルバーです
// IDと新しいステータスを受け取り、テストスイートのステータスを更新します
func (r *mutationResolver) UpdateTestSuiteStatus(ctx context.Context, id string, status model.SuiteStatus) (*model.TestSuite, error) {
	// DTOに変換
	statusDTO := &dto.TestSuiteStatusUpdateDTO{
		Status: mapEnumToStatus(status),
	}

	// ユースケースを呼び出し
	result, err := r.TestSuiteUseCase.UpdateTestSuiteStatus(ctx, id, statusDTO)
	if err != nil {
		return nil, err
	}

	// レスポンスをGraphQLモデルに変換
	return &model.TestSuite{
		ID:                   result.ID,
		Name:                 result.Name,
		Description:          result.Description,
		Status:               mapStatusToEnum(result.Status),
		EstimatedStartDate:   result.EstimatedStartDate,
		EstimatedEndDate:     result.EstimatedEndDate,
		RequireEffortComment: result.RequireEffortComment,
		Progress:             result.Progress,
		CreatedAt:            result.CreatedAt,
		UpdatedAt:            result.UpdatedAt,
	}, nil
}

// TestSuite はテストスイート取得クエリのリゾルバーです
// IDを指定して単一のテストスイートを取得します
func (r *queryResolver) TestSuite(ctx context.Context, id string) (*model.TestSuite, error) {
	// ユースケースを呼び出し
	result, err := r.TestSuiteUseCase.GetTestSuite(ctx, id)
	if err != nil {
		return nil, err
	}

	// 結果がnilの場合は明示的にnilを返す（GraphQLではnilが許容されるフィールドなので）
	if result == nil {
		return nil, nil
	}

	// レスポンスをGraphQLモデルに変換
	return TestSuiteDTOToModel(result), nil
}

// TestSuites はテストスイート一覧取得クエリのリゾルバーです
// オプションでステータスによるフィルタリングやページネーションができます
func (r *queryResolver) TestSuites(ctx context.Context, status *model.SuiteStatus, page *int, pageSize *int) (*model.TestSuiteConnection, error) {
	// DTOに変換
	params := &dto.TestSuiteQueryParamDTO{}

	// NULLチェックを追加
	if page != nil {
		params.Page = page
	} else {
		defaultPage := 1
		params.Page = &defaultPage
	}

	if pageSize != nil {
		params.PageSize = pageSize
	} else {
		defaultPageSize := 10 // デフォルト値
		params.PageSize = &defaultPageSize
	}

	if status != nil {
		statusStr := mapEnumToStatus(*status)
		params.Status = &statusStr
	}

	// ユースケースを呼び出し
	result, err := r.TestSuiteUseCase.ListTestSuites(ctx, params)
	if err != nil {
		return nil, err
	}

	// エッジを作成
	edges := make([]*model.TestSuiteEdge, len(result.TestSuites))
	for i, ts := range result.TestSuites {
		edges[i] = &model.TestSuiteEdge{
			Node: &model.TestSuite{
				ID:                   ts.ID,
				Name:                 ts.Name,
				Description:          ts.Description,
				Status:               mapStatusToEnum(ts.Status),
				EstimatedStartDate:   ts.EstimatedStartDate,
				EstimatedEndDate:     ts.EstimatedEndDate,
				RequireEffortComment: ts.RequireEffortComment,
				Progress:             ts.Progress,
				CreatedAt:            ts.CreatedAt,
				UpdatedAt:            ts.UpdatedAt,
			},
			Cursor: ts.ID, // IDをカーソルとして使用
		}
	}

	// 接続を作成
	return &model.TestSuiteConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     len(result.TestSuites) == *params.PageSize,
			HasPreviousPage: *params.Page > 1,
			StartCursor:     getStartCursor(edges),
			EndCursor:       getEndCursor(edges),
		},
		TotalCount: result.Total,
	}, nil
}

// TestSuiteStatusChanged はテストスイートのステータス変更を監視するサブスクリプションのリゾルバーです
// クライアントはこのサブスクリプションを使用してリアルタイムでステータス変更を受け取れます
func (r *subscriptionResolver) TestSuiteStatusChanged(ctx context.Context) (<-chan *model.TestSuite, error) {
	// この実装は簡易版です。実際の実装ではWebSocketやPub/Subの仕組みを使用します
	ch := make(chan *model.TestSuite, 1)

	// 実際のサブスクリプション処理はここに実装
	// 現在はダミーのチャネルを返すだけ

	return ch, nil
}

// Cases はTestGroupのcasesフィールドリゾルバーです
// 指定されたグループに属するテストケース一覧を取得します
func (r *testGroupResolver) Cases(ctx context.Context, obj *model.TestGroup) ([]*model.TestCase, error) {
	// objのNULLチェック
	if obj == nil {
		return nil, nil
	}

	// DataLoaderを取得
	loader, err := dataloader.GetTestCaseLoader(ctx)
	if err != nil {
		// DataLoaderが使用できない場合は従来の方法でデータを取得
		caseDTOs, err := r.TestCaseUseCase.GetCasesByGroupID(ctx, obj.ID)
		if err != nil {
			return nil, err
		}

		if caseDTOs == nil {
			return []*model.TestCase{}, nil
		}

		cases := make([]*model.TestCase, len(caseDTOs))
		for i, dto := range caseDTOs {
			cases[i] = TestCaseDTOToModel(dto)
		}

		return cases, nil
	}

	// DataLoaderを使用してデータを取得
	caseDTOs, err := loader.GetCasesByGroupID(ctx, obj.ID)
	if err != nil {
		return nil, err
	}

	if caseDTOs == nil {
		return []*model.TestCase{}, nil
	}

	cases := make([]*model.TestCase, len(caseDTOs))
	for i, dto := range caseDTOs {
		cases[i] = TestCaseDTOToModel(dto)
	}

	return cases, nil
}

// Groups はTestSuiteのgroupsフィールドリゾルバーです
// 指定されたテストスイートに属するグループ一覧を取得します
func (r *testSuiteResolver) Groups(ctx context.Context, obj *model.TestSuite) ([]*model.TestGroup, error) {
	// objのNULLチェック
	if obj == nil {
		return nil, nil
	}

	// DataLoaderを取得
	loader, err := dataloader.GetTestGroupLoader(ctx)
	if err != nil {
		// DataLoaderが使用できない場合は従来の方法でデータを取得
		groupDTOs, err := r.TestGroupUseCase.GetGroupsBySuiteID(ctx, obj.ID)
		if err != nil {
			return nil, err
		}

		if groupDTOs == nil {
			return []*model.TestGroup{}, nil
		}

		groups := make([]*model.TestGroup, len(groupDTOs))
		for i, dto := range groupDTOs {
			groups[i] = TestGroupDTOToModel(dto)
		}

		return groups, nil
	}

	// DataLoaderを使用してデータを取得
	groupDTOs, err := loader.GetGroupsBySuiteID(ctx, obj.ID)
	if err != nil {
		return nil, err
	}

	if groupDTOs == nil {
		return []*model.TestGroup{}, nil
	}

	groups := make([]*model.TestGroup, len(groupDTOs))
	for i, dto := range groupDTOs {
		groups[i] = TestGroupDTOToModel(dto)
	}

	return groups, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// TestGroup returns generated.TestGroupResolver implementation.
func (r *Resolver) TestGroup() generated.TestGroupResolver { return &testGroupResolver{r} }

// TestSuite returns generated.TestSuiteResolver implementation.
func (r *Resolver) TestSuite() generated.TestSuiteResolver { return &testSuiteResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type testGroupResolver struct{ *Resolver }
type testSuiteResolver struct{ *Resolver }
