package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"net/http"

	"github.com/FUJI0130/go-ddd-ca/internal/interface/graphql/auth"
	"github.com/FUJI0130/go-ddd-ca/internal/interface/graphql/model"
	"github.com/FUJI0130/go-ddd-ca/internal/usecase/port"
)

// Login はユーザー認証を行い、JWTトークンを発行するリゾルバーです
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	loginRequest := &port.LoginRequest{
		Username: username,
		Password: password,
	}

	result, err := r.AuthUseCase.Login(ctx, loginRequest)
	if err != nil {
		return nil, err
	}

	// HTTPレスポンスライターアクセス
	w := auth.GetResponseWriterFromContext(ctx)
	if w != nil {
		// HttpOnly Cookie設定
		http.SetCookie(w, &http.Cookie{
			Name:     "auth_token",
			Value:    result.Token,
			HttpOnly: true,
			Secure:   false, // 開発環境用（本番ではtrue）
			SameSite: http.SameSiteStrictMode,
			Path:     "/",
			Expires:  result.ExpiresAt,
		})

		http.SetCookie(w, &http.Cookie{
			Name:     "refresh_token",
			Value:    result.RefreshToken,
			HttpOnly: true,
			Secure:   false, // 開発環境用（本番ではtrue）
			SameSite: http.SameSiteStrictMode,
			Path:     "/",
			Expires:  result.ExpiresAt,
		})
	}

	// レスポンスからトークンを除外
	return &model.AuthPayload{
		Token:        result.Token,        // ← 正常なJWT返却
		RefreshToken: result.RefreshToken, // ← 正常なリフレッシュトークン返却
		User:         mapUserEntityToModel(result.User),
		ExpiresAt:    result.ExpiresAt,
	}, nil
}

// RefreshToken はリフレッシュトークンを使用して新しいアクセストークンを発行するリゾルバーです
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.AuthPayload, error) {
	// 認証ユースケースの呼び出し
	result, err := r.AuthUseCase.RefreshToken(ctx, refreshToken)
	if err != nil {
		return nil, err
	}

	// レスポンスの作成
	return &model.AuthPayload{
		Token:        result.Token,
		RefreshToken: result.RefreshToken,
		User:         mapUserEntityToModel(result.User),
		ExpiresAt:    result.ExpiresAt,
	}, nil
}

// Logout はリフレッシュトークンを無効化するリゾルバーです
func (r *mutationResolver) Logout(ctx context.Context, refreshToken string) (bool, error) {
	// 認証ユースケースの呼び出し
	err := r.AuthUseCase.Logout(ctx, refreshToken)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Me は認証済みユーザーの情報を取得するリゾルバーです
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// コンテキストからユーザー情報を取得
	user := auth.GetUserFromContext(ctx)
	if user == nil {
		// 通常は@authディレクティブによって認証チェックが行われるため、
		// このエラーには到達しないはずだが、念のため
		return nil, nil
	}

	// ユーザーエンティティをGraphQLモデルに変換
	return mapUserEntityToModel(user), nil
}
