# Protocol Buffers設計ドキュメント

このドキュメントはテストケース管理システムにおけるProtocol Buffers/gRPCの設計方針を定義します。

## 1. 概要

### 1.1 目的
このドキュメントは、テストケース管理システムにおけるProtocol Buffersの設計方針とgRPCサービスのAPI設計原則を定義します。一貫性のある実装と保守性の高いコードベースを維持するための指針として作成されています。

### 1.2 適用範囲
- テストスイート関連のすべてのProtocol Buffersメッセージ定義
- gRPCサービスインターフェースの設計
- エラーハンドリングの実装
- 後方互換性の維持方針

### 1.3 設計の基本方針
- クリーンアーキテクチャに準拠した設計
- ドメイン層との整合性維持
- 型安全性の確保
- 明確な責務分離
- 拡張性を考慮した設計

### 1.4 ドキュメントの利用タイミング
- 新規APIエンドポイント追加時の設計レビュー
- コード生成時の設定確認
- レビュー時のチェックリスト
- 新規開発者のオンボーディング
- 既存実装の整合性確認

## 2. メッセージ定義の設計方針

### 2.1 型の選択基準
- 基本型（string, int32, bool）は可能な限りそのまま使用する
- 日時はgoogle.protobuf.Timestampを使用
- ENUMは名前空間を考慮した命名（例: SUITE_STATUS_PREPARATION）
- 固定長配列よりもrepeated フィールドを優先
- 可変長フィールドには制約を設けない（アプリケーション層でバリデーション）

### 2.2 命名規則
- メッセージ名: UpperCamelCase（例: TestSuite, CreateTestSuiteRequest）
- フィールド名: snake_case（例: estimated_start_date）
- ENUM値: UPPER_SNAKE_CASE（例: SUITE_STATUS_PREPARATION）
- RPCメソッド名: UpperCamelCase（例: CreateTestSuite）
- パッケージ名: 小文字（例: testsuite.v1）

### 2.3 フィールド番号の割り当て
- 1～15: 頻繁に使用されるフィールド（1バイトで符号化）
- 16以上: それ以外のフィールド（2バイト以上で符号化）
- ID、名前、説明などの基本情報は小さい番号から割り当て
- 作成日時、更新日時などのメタデータは大きい番号に割り当て
- 将来の拡張に備えて番号の間隔を十分に取る

### 2.4 バージョニング戦略
- パッケージ名に明示的なバージョン番号を含める（例: testsuite.v1）
- メジャーバージョンの変更は破壊的変更を含む場合のみ
- 後方互換性のある変更はマイナーバージョンで対応

## 3. gRPCサービスのAPI設計方針

### 3.1 エンドポイントの責務と粒度
- 単一の責務を持つエンドポイント設計
- CRUD操作に対応する基本エンドポイントの提供:
  - Create: リソースの作成
  - Get: 単一リソースの取得
  - Update: リソースの更新
  - List: 複数リソースの取得
- 特殊操作（ステータス更新など）は専用エンドポイントとして分離
- 検索条件は専用のリクエストメッセージで定義

### 3.2 パラメータ設計
- 必須パラメータは基本型として定義
- オプショナルパラメータはoptionalキーワードを使用
- 複数の関連パラメータはグループ化（例: UpdateTestSuiteParams）
- ページネーションはpage/page_sizeパターンを採用
- フィルタリング条件は明示的に定義（例: status, start_date, end_date）

### 3.3 ストリーミングAPIの設計基準
- リアルタイム更新が必要な場合のみストリーミングを使用
- サーバーストリーミングは状態変更の監視に使用（例: WatchTestSuite）
- ポーリング間隔は設定可能に（デフォルト10秒）
- 初期状態の即時返却
- 更新された場合のみデータを送信
- コンテキストキャンセルによる適切な終了処理

### 3.4 タイムアウトと再試行の設定
- クライアント側でのタイムアウト設定を推奨
- 長時間実行操作には適切なタイムアウト値を設定
- 再試行はベストエフォートで実装
- 再試行間隔は指数バックオフを推奨

## 4. エラーハンドリング戦略

### 4.1 gRPCステータスコードの使用方針
- OK (0): 成功
- INVALID_ARGUMENT (3): クライアントが無効な引数を提供
- NOT_FOUND (5): 要求されたリソースが見つからない
- ALREADY_EXISTS (6): 作成しようとしたリソースが既に存在する
- PERMISSION_DENIED (7): 権限がない
- FAILED_PRECONDITION (9): システムが操作を実行できる状態ではない
- ABORTED (10): 操作が中断された
- INTERNAL (13): 内部エラー

### 4.2 エラーメッセージのフォーマット
- 統一されたフォーマット: "failed to [操作]: [理由]"
- ユーザー向けメッセージは具体的かつ行動可能な情報を提供
- 内部エラー詳細はログに記録し、クライアントには抽象化された情報のみ返す
- デバッグ情報は開発環境のみで表示

### 4.3 カスタムエラーとgRPCエラーの変換
- ドメインエラーからgRPCエラーへの一貫した変換
- エラータイプに基づく適切なステータスコードへのマッピング
- エラー変換レイヤーの設置（UseCase層とgRPCハンドラ間）
- エラーコンテキストの保持と伝播


## 5. 後方互換性の維持方針

### 5.1 フィールドの追加/削除のルール
- 既存フィールドの削除は避ける
- 既存フィールドの型変更は避ける
- 新しいフィールドは常にoptionalとして追加
- 削除が必要な場合はdeprecatedとマーク
- ENUMへの追加は可能、既存値の削除は避ける
- フィールド番号の再利用は禁止

### 5.2 バージョニング戦略
- パッケージ名でのメジャーバージョン管理（v1, v2, ...）
- 破壊的変更が必要な場合は新しいバージョンを作成
- 古いバージョンのサポート期間を明確に定義
- 複数バージョンの並行運用を考慮した設計

### 5.3 既存クライアントへの影響を最小限に抑える方法
- 新しいフィールドにはデフォルト値を設定
- クライアントライブラリの自動生成と配布
- バージョン移行ガイドの提供
- 新旧バージョン間の変換ユーティリティの提供

## 6. ドキュメント運用ガイドライン

### 6.1 更新タイミング
- Protocol Buffersの定義変更時
- APIエンドポイントの追加/変更時
- エラーハンドリング戦略の変更時
- バージョニング戦略の見直し時

### 6.2 レビュープロセスでの利用方法
- 設計レビュー時のチェックリストとして活用
- 実装の整合性確認のためのリファレンスとして使用
- コードジェネレータの設定パラメータの検証

### 6.3 関連ドキュメントとの整合性確認
- ドメインモデル定義との整合性
- API仕様書との整合性
- エラーハンドリング方針との整合性

### 6.4 チェックリストとしての活用方法
- 新規API追加時の設計確認
- コード生成パラメータの確認
- バージョン管理の確認
- エラーハンドリング実装の確認